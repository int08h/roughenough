use std::env;
use std::path::Path;

use ssh_agent_client_rs::Client;
use ssh_key::{PrivateKey, PublicKey};
use tracing::{debug, info};
use zeroize::Zeroize;

use crate::seed::{BackendError, Seed, SeedBackend};

/// Uses `ssh-agent` to hold the private key and perform signing operations on our behalf
pub struct SshAgentBackend {
    connection: Client,
    public_key: Option<PublicKey>,
    seed_len: usize,
}

impl SshAgentBackend {
    pub fn new(sock_path: Option<String>) -> Result<SshAgentBackend, BackendError> {
        let path = sock_path
            .or_else(|| env::var("SSH_AUTH_SOCK").ok())
            .ok_or_else(|| {
                BackendError::Ssh("no path provided and SSH_AUTH_SOCK not set".to_string())
            })?;

        let client = Client::connect(Path::new(&path))
            .map_err(|e| BackendError::Ssh(format!("failed connecting to ssh-agent: {e}")))?;

        debug!("ssh-agent connected to agent: {}", path);

        Ok(SshAgentBackend {
            connection: client,
            public_key: None,
            seed_len: 0,
        })
    }
}

impl Drop for SshAgentBackend {
    fn drop(&mut self) {
        // `ssh_agent_client_rs::remove_identity` requires the *private* key. It's an implementation
        // oddity as OpenSSH `ssh-add -d` takes the public key.
        // Instead of caching the private key (which defeats the purpose of this whole thing),
        // remove all keys
        match self.connection.remove_all_identities() {
            Ok(_) => info!("removed all identities from ssh-agent"),
            Err(e) => debug!("failed removing identities from ssh-agent: {e}"),
        };
    }
}

impl SeedBackend for SshAgentBackend {
    fn store_seed(&mut self, seed: Seed) -> Result<(), BackendError> {
        let private_key = key_from_seed(seed.expose());

        self.connection.add_identity(&private_key)?;
        self.public_key = Some(private_key.public_key().clone());
        self.seed_len = seed.len();

        debug!(
            "added {}-byte seed as private key to ssh-agent",
            self.seed_len
        );
        Ok(())
    }

    fn get_seed(&self) -> Result<Seed, BackendError> {
        let msg = "get_seed is not supported for ssh-agent backend".to_string();
        Err(BackendError::NotSupported(msg))
    }

    fn sign(&mut self, data: &[u8]) -> Result<[u8; 64], BackendError> {
        let key: &PublicKey = self.public_key.as_ref().expect("bug: no public key?");

        let sig = self.connection.sign(key, data)?;
        let sig_bytes: [u8; 64] = sig.as_bytes().try_into().expect("infallible");

        Ok(sig_bytes)
    }

    fn seed_len(&self) -> usize {
        self.seed_len
    }

    fn public_key(&self) -> protocol::tags::PublicKey {
        protocol::tags::PublicKey::from(self.public_key_bytes())
    }

    fn public_key_bytes(&self) -> [u8; 32] {
        let edkey = self
            .public_key
            .as_ref()
            .unwrap()
            .key_data()
            .ed25519()
            .unwrap();
        edkey.0.to_vec().try_into().expect("infallible")
    }
}

fn key_from_seed(seed: &[u8]) -> PrivateKey {
    let mut seed0: [u8; 32] = seed.try_into().expect("seed is 32 bytes");
    let key = ssh_key::private::Ed25519Keypair::from_seed(&seed0);
    seed0.zeroize();

    let mut private_key = ssh_key::PrivateKey::from(key);
    private_key.set_comment("roughenough-seed");

    private_key
}

#[cfg(test)]
mod tests {
    use aws_lc_rs::signature::ED25519;

    use super::*;
    use crate::online::test_util::enable_logging;

    // Verify that a signature generated by `ssh-agent` is verifiable by aws-lc-rs
    #[test]
    fn signature_validates_cross_libraries() {
        enable_logging();

        // Given an SshAgentBackend
        let mut agent = SshAgentBackend::new(None).unwrap();
        let seed = Seed::new_random();
        agent.store_seed(seed).unwrap();

        // When the ssh-agent signs something
        let data = b"hello world";
        let signature = agent.sign(data).unwrap();

        // Then that signature validates with aws-lc-rs
        let key = agent.public_key_bytes();
        let pub_key = aws_lc_rs::signature::UnparsedPublicKey::new(&ED25519, key);
        pub_key.verify(data, &signature).unwrap();
    }
}
